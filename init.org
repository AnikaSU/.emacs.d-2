#+TITLE: Emacs literate configuration 
#+AUTHOR: Mathieu Basille
#+EMAIL: basille@ufl.edu
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle yes


* Table of Contents                                            :TOC:
 - [[#emacs-packages][Emacs packages]]
   - [[#additional-functions][Additional functions]]
 - [[#interface][Interface]]
   - [[#color-theme][Color theme]]
   - [[#frames][Frames]]
   - [[#windows][Windows]]
   - [[#buffers][Buffers]]
   - [[#mode-line][Mode line]]
   - [[#minibuffer][Minibuffer]]
 - [[#buffer-editing][Buffer editing]]
   - [[#spell-check-and-syntax-check][Spell check and syntax check]]
   - [[#file-saving][File saving]]
 - [[#utilities][Utilities]]
   - [[#file-manager][File manager]]
   - [[#git][GIT]]
   - [[#shell][Shell]]
   - [[#pdf][PDF]]
   - [[#eww-web-browser][EWW web browser]]
 - [[#major-modes][Major modes]]
   - [[#yaml][YAML]]
   - [[#org][Org]]
   - [[#latex][LaTeX]]
   - [[#markdown][Markdown]]
   - [[#ess][ESS]]
   - [[#sql][SQL]]
   - [[#web][Web]]
   - [[#polymode][Polymode]]
 - [[#postface][Postface]]

* Emacs packages

Emacs now provide an entire ecosystem of packages, in various
repositories, and handles them through the =package= utility.  Emacs
packages can come from different repositories. We only activate the
official GNU repository, as well as [[http://melpa-stable.milkbox.net/][MELPA-stable]], MELPA and ORG:

#+BEGIN_SRC emacs-lisp
  (setq package-archives 
        '(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa-stable" . "https://stable.melpa.org/packages/")
          ("melpa" . "https://melpa.org/packages/")
          ("org" . "https://orgmode.org/elpa/")
          )
        package-archive-priorities
        '(("org"          . 20)
          ("melpa-stable" . 10)
          ("gnu"          . 5)
          ("melpa"        . 0)
          ))
#+END_SRC

We now load it and make sure Emacs does not load it automatically 
a second time at startup, after all configuration is loaded:

#+BEGIN_SRC emacs-lisp
  (package-initialize)
  (setq package-enable-at-startup nil)
#+END_SRC

We can now automatically install the packages that are not in Debian
repositories. We first list these packages:

#+BEGIN_SRC emacs-lisp
  (setq package-list '(
                       2048-game
                       aggressive-indent
                       all-the-icons-dired
                       anzu
                       apropospriate-theme
                       auctex
                       auctex-latexmk
                       bonjourmadame
                       centered-window
                       circadian
                       col-highlight
                       company
                       company-auctex
                       counsel
                       counsel-world-clock
                       color-theme-sanityinc-tomorrow 
                       dim
                       dimmer
                       dired+
                       dired-narrow
                       dired-quick-sort
                       dired-sidebar
                       dired-subtree
                       ebib
                       eshell-git-prompt
                       ess
                       ess-smart-underscore
                       expand-region
                       flycheck
                       flx
                       format-sql
                       hideshow-org
                       highlight 
                       highlight-indent-guides
                       ivy-bibtex
                       magit
                       magit-gitflow
                       markdown-mode
                       markdown-toc
                       minimap
                       ;; minions          ; Will be for Emacs 25.3
                       ;; moody            ; Will be for Emacs 25.3
                       multiple-cursors
                       neotree
                       nord-theme
                       pdf-tools
                       polymode
                       org
                       org-bullets
                       powerline
                       rubik
                       smex
                       sql-indent
                       sqlup-mode
                       string-inflection
                       sudden-death 
                       toc-org
                       web-mode
                       xkcd
                       yaml-mode
                       ))
  ;; Markdown-mode from MELPA, and not MELPA stable
  (setq package-pinned-packages
        '((markdown-mode         . "melpa")
          (ivy-bibtex            . "melpa")))
#+END_SRC

Then fetch the list of packages available and install the missing
packages:

#+BEGIN_SRC emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))
  (dolist (package package-list)
    (unless (package-installed-p package)
      (package-install package)))
#+END_SRC

From now on, given that all packages are installed with a purpose,
Emacs will silently accept redefinitions of functions by packages:

#+BEGIN_SRC emacs-lisp
  (setq ad-redefinition-action 'accept)
#+END_SRC

** Additional functions

Additional Lisp functions (=.el= files) are placed in the =functions=
folder of the Emacs profile:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path (concat user-emacs-directory "functions"))
#+END_SRC


* Interface

Disable the splash screen:

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t)
#+END_SRC

Menu disabled by default. Show it with ~C-S-F1~:

#+BEGIN_SRC emacs-lisp
  (global-set-key [(ctrl shift f1)] 'menu-bar-mode)
#+END_SRC

Screen saver after 5 minutes:

#+BEGIN_SRC emacs-lisp
  (require 'zone)
  (zone-when-idle 300)
#+END_SRC


** Color theme

With the help of the package [[https://github.com/guidoschmidt/circadian.el][circadian]], Emacs can switch themes based
on sunrise and sunset. I will use [[https://github.com/waymondo/apropospriate-theme][apropospriate-light-theme]] during the
day, and [[https://github.com/arcticicestudio/nord-emacs][Nord Emacs]] at night (with brightness of comments at
15%). Coordinates are for South Florida:

#+BEGIN_SRC emacs-lisp
  (setq nord-comment-brightness 20)
  ;; (load-theme 'nord t)
  ;; Fort Lauderdale
  ;; (setq calendar-latitude 26.084534)
  ;; (setq calendar-longitude -80.238454)
  ;; (setq calendar-location-name "Fort Lauderdale, FL")
  ;; Trondheim
  ;; (setq calendar-latitude 63.446827)
  ;; (setq calendar-longitude 10.421906)
  ;; (setq calendar-location-name "Trondheim, NO")
  ;; Stellenbosch
  ;; (setq calendar-latitude -33.932105)
  ;; (setq calendar-longitude 18.860152)
  ;; (setq calendar-location-name "Stellenbosch, SA")
  ;; London
  ;; (setq calendar-latitude 53.4084)
  ;; (setq calendar-longitude -2.9916)
  ;; (setq calendar-location-name "London, UK")
  ;; Montpellier
  (setq calendar-latitude 43.6108)
  (setq calendar-longitude 3.8767)
  (setq calendar-location-name "Montpellier, FR")
  (setq circadian-themes '((:sunrise . apropospriate-light)
                           (:sunset  . nord)))
  (circadian-setup)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; ;; Alternatively with theme-changer:
  ;; (require 'theme-changer)
  ;; ;; Use color-theme package instead Emacs 24 color theme facility
  ;; (setq theme-changer-mode "color-theme")
  ;; (change-theme 'apropospriate-light 'nord)
#+END_SRC


** Frames

Frames (generally called windows) have a title instead of
=emacs25@<computer>=:

#+BEGIN_SRC emacs-lisp
  (setq frame-title-format '(buffer-file-name "Emacs: %b (%f)" "Emacs: %b"))
#+END_SRC


** Windows

Emacs will split horizontally if the current window is at least 100
columns wide:

#+BEGIN_SRC emacs-lisp
  (setq split-width-threshold 100)
;; Emacs starts split horizontaly in the middle (only if started as GUI,
;; and not with =-nw=):
  
  ;; (defun my-frame-config (frame)
  ;;   "Split the current frame if in a GUI"
  ;;   (with-selected-frame frame
  ;;     (if (display-graphic-p)
  ;;         (progn
  ;;           (message "after-make-frame-functions hook: split-window-horizontally")
  ;;           (split-window-horizontally)))))

  ;; (add-hook 'after-make-frame-functions 'my-frame-config)

  ;; (if (not (daemonp))
  ;;     (split-window-horizontally))
#+END_SRC

Visually highlight selected buffer, by dimming other buffers (package
=dimmer=):

#+BEGIN_SRC emacs-lisp
  (dimmer-activate)
  (setq dimmer-percent 0.15)
#+END_SRC

List of buffers with =ibuffer= bound to ~C-x C-b~ (replaces
=list-buffers=); the list automatically refreshes, and group buffers
according to =ibuffer-saved-filter-groups= (empty groups are hidden);
additionally, there is no confirmation to kill unmodified buffers
(=ibuffer-expert=), and kill is bound to ~k~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)

  (setq ibuffer-saved-filter-groups
        '(("buffer-groups"
           ("Magit" (name . "^\\*magit"))
           ("Help" (or (name . "^\\*Help\\*$")
                       (name . "^\\*Apropos\\*$")
                       (name . "^\\*Messages\\*$")
                       (name . "^\\*scratch\\*$")
                       (name . "^\\*info\\*$")))
           ("Org" (or (mode . org-mode)
                      (filename . ".org$")))
           ("R" (or (mode . ess-mode)
                    (filename . ".R$")
                    (filename . ".Rmd$")
                    (filename . ".Rnw$")
                    (name . "^\\*ESS\\*$")))
           ("LaTeX" (or (mode . latex-mode)
                    (filename . ".tex$")))
           ("Web Dev" (or (mode . html-mode)
                          (mode . css-mode)
                          (mode . js-mode)))
           ("emacs-config" (filename . ".emacs.d")))))

  (setq
   ibuffer-show-empty-filter-groups nil
   ibuffer-expert t)
          
  (add-hook 'ibuffer-mode-hook
            '(lambda ()
               (ibuffer-auto-mode 1)
               (ibuffer-switch-to-saved-filter-groups "buffer-groups")
               (define-key ibuffer-mode-map (kbd "k") 'ibuffer-do-delete)))
#+END_SRC

Use ~M-<arrows>~ to move between windows (package =windmove=, built in
Emacs):

#+BEGIN_SRC emacs-lisp
  (windmove-default-keybindings 'meta)
#+END_SRC

Next window with ~C-~~ (key above TAB):

#+BEGIN_SRC emacs-lisp
  (global-set-key [C-dead-grave] 'other-window)
#+END_SRC

Mouse wheel does not accelerate:

#+BEGIN_SRC emacs-lisp
  (setq mouse-wheel-progressive-speed nil)
#+END_SRC

Scroll 2 lines from the edge:

#+BEGIN_SRC emacs-lisp
  (setq scroll-margin 2)
#+END_SRC

Prevent lateral scrolling from touchpad to beep:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<mouse-7>")
                  (lambda () (interactive)))
  (global-set-key (kbd "<mouse-6>")
                  (lambda () (interactive)))
#+END_SRC

Visible bells (flashes the frame):

#+BEGIN_SRC emacs-lisp
  visible-bell t
#+END_SRC

Minimap in side panel with ~C-F5~:

#+BEGIN_SRC emacs-lisp
  (global-set-key [(ctrl f5)] 'minimap-mode)
#+END_SRC

Ediff tries to split sensibly, and keep the Ediff window in the same
frame:

#+BEGIN_SRC emacs-lisp
  (setq ediff-split-window-function 'split-window-sensibly)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+END_SRC


** Buffers

Empty scratch buffer:

#+BEGIN_SRC emacs-lisp
  (setq initial-scratch-message nil)
#+END_SRC

Lines soft wrapped at word boundary (with fringe indicators):

#+BEGIN_SRC emacs-lisp
  (global-visual-line-mode 1)
  (setq visual-line-fringe-indicators '(left-curly-arrow right-curly-arrow))
#+END_SRC

~F10~ to toggle line wrapping (activated by default):

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f10)] 'toggle-truncate-lines)
#+END_SRC

Highlight current line globally (and toggle it with ~C-F10~):

#+BEGIN_SRC emacs-lisp
  (global-hl-line-mode)
  (global-set-key [(ctrl f10)] 'global-hl-line-mode)
#+END_SRC


Highlight columns ([[https://www.emacswiki.org/emacs/col-highlight.el][col-highlight]]): ~C-S-F10~ to toggle column highlight
mode.

#+BEGIN_SRC emacs-lisp
  (global-set-key [(ctrl shift f10)] 'column-highlight-mode)
#+END_SRC

Highlight regions ([[https://www.emacswiki.org/emacs/highlight.el][highlight]]): ~F9~ to highlight, ~C-F9~ to move to
the next highlighted text, ~C-S-F9~ to unhighlight everything.

#+BEGIN_SRC emacs-lisp
  ;; (set-face-attribute 'highlight nil 
  ;;                   :background "saddle brown")
  (global-set-key [(f9)] 'hlt-highlight)
  (global-set-key [(ctrl f9)] 'hlt-next-highlight)
  (global-set-key [(ctrl shift f9)] 'hlt-unhighlight-region)
#+END_SRC

Highlight indentation in Programming mode (=highlight-indent-guides=):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'highlight-indent-guides-mode)
  (setq highlight-indent-guides-method 'character) ; use 'column for more visible guides
#+END_SRC

Count words in region using ~C-+~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-+") 'count-words)
#+END_SRC

Kill THIS buffer with ~C-x k~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x k") 'kill-this-buffer)
#+END_SRC


*** Navigation

Recenter with ~C-l~ starts with top, then middle, then bottom:

#+BEGIN_SRC emacs-lisp
  (setq recenter-positions '(top middle bottom))
#+END_SRC

[[https://github.com/magnars/expand-region.el][Expand region]] with ~C-=~ (then continue to expand by pressing ~=~ or
contract by pressing ~-~):

#+BEGIN_SRC emacs-lisp
  ;;  (require 'expand-region)
#+END_SRC

[[https://github.com/shanecelis/hideshow-org][HideShow]] (fold or unfold functions/regions with ~TAB~ or ~C-S-F10~ if
the code is already indented) for Programming mode:

#+BEGIN_SRC emacs-lisp
  (require 'hideshow-org)
  (add-hook 'prog-mode-hook
            (lambda()
              (hs-org/minor-mode)
              (local-set-key [(ctrl shift f10)] 'hs-toggle-hiding)
              ))
  (dim-minor-name 'hs-minor-mode "")
#+END_SRC

Saveplace: Go back to last position where the point was in a file
(save positions in =.emacs.d/cache/saved-places=):

#+BEGIN_SRC emacs-lisp
  (save-place-mode 1)
  (setq save-place-file (concat user-emacs-directory "cache/saved-places"))
#+END_SRC

Use position registers (a sort of bookmark) with ~F1—F4~: ~C-F1~ to
~C-F4~ to save a register, ~F1~ to ~F4~ to jump to a saved register:

#+BEGIN_SRC emacs-lisp
  (global-set-key [(f1)]
                  (lambda () (interactive) (jump-to-register 1 nil)))
  (global-set-key [(ctrl f1)]
                  (lambda () (interactive) (point-to-register 1 nil)))
  (global-set-key [(f2)]
                  (lambda () (interactive) (jump-to-register 2 nil)))
  (global-set-key [(ctrl f2)]
                  (lambda () (interactive) (point-to-register 2 nil)))
  (global-set-key [(f3)]
                  (lambda () (interactive) (jump-to-register 3 nil)))
  (global-set-key [(ctrl f3)]
                  (lambda () (interactive) (point-to-register 3 nil)))
  (global-set-key [(f4)]
                  (lambda () (interactive) (jump-to-register 4 nil)))
  (global-set-key [(ctrl f4)]
                  (lambda () (interactive) (point-to-register 4 nil)))
#+END_SRC

Imenu lists the main parts of a document (sections, headers, etc.) to
navigate interactively a long document (bound to ~C-M-=~); we ask
Imenu to stay up to date automatically:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-M-=") #'imenu)
  (setq imenu-auto-rescan t)
#+END_SRC

Bookmarks are saved in =.emacs.d/cache/bookmarks=, are set with
~C-S-F1~ and listed with ~C-S-F4~:

#+BEGIN_SRC emacs-lisp
  (setq bookmark-default-file (concat user-emacs-directory "cache/bookmarks"))
  (global-set-key [(ctrl shift f3)] 'bookmark-set)
  (global-set-key [(ctrl shift f4)] 'list-bookmarks)
#+END_SRC


** Mode line

Use a Power line:

(to be replaced by =[[https://github.com/tarsius/moody][moody]]= after Emacs 25.3)

#+BEGIN_SRC emacs-lisp
  (powerline-center-theme)
  (setq powerline-default-separator 'wave)
#+END_SRC

Display line and column number in the mode line:

#+BEGIN_SRC emacs-lisp
  (column-number-mode 1)
#+END_SRC

[[https://github.com/syohex/emacs-anzu][Anzu]]: display current match and total matches information in the
mode-line, and show replacement interactively. Replace is bound to
~C-r~, and replace using a RegExp is bound to ~C-M-r~:

#+BEGIN_SRC emacs-lisp
  (global-anzu-mode 1)
  (anzu-mode 1)
  (dim-minor-name 'anzu-mode "")
  (global-set-key (kbd "C-r") 'anzu-query-replace)
  (global-set-key (kbd "C-M-r") 'anzu-query-replace-regexp)
#+END_SRC

"Diminish" =auto-fill= (automatically break long lines while typing),
=auto-revert= (which is used by Magit to automatically update file
content), =visual-line-mode= (word wrapping at the end of long lines),
=eldoc= (display function arguments in the minibuffer), Lisp
Interaction (replaced with just "Lisp"):

(to be replaced by =[[https://github.com/tarsius/minions][minions]]= after Emacs 25.3)

#+BEGIN_SRC emacs-lisp
  (dim-minor-name 'auto-fill-function "")
  (dim-minor-name 'auto-revert-mode "")
  (dim-minor-name 'visual-line-mode "")
  (dim-minor-name 'eldoc-mode "")
  (dim-minor-name 'eldoc-mode "")
  (add-hook 'emacs-lisp-mode-hook 
            (lambda()
              (setq mode-name "Lisp")))
#+END_SRC


** Minibuffer

Ivy for completion: =[[http://oremacs.com/swiper/][Ivy]]= comes with =Counsel= as dependencies; needs
to install =flx= for better sorting. Ivy mode and [[https://github.com/abo-abo/swiper#user-content-counsel][Counsel mode]]
everywhere:

#+BEGIN_SRC emacs-lisp
  (ivy-mode 1)
  (counsel-mode 1)
#+END_SRC

Simple customization:

#+BEGIN_SRC emacs-lisp
  (setq
   ;; Add recent files and bookmarks to ‘ivy-switch-buffer’
   ivy-use-virtual-buffers t
   ;; Format counters with (xx/XX)
   ivy-count-format "(%d/%d) "
   ;; Use input with C-p
   ivy-use-selectable-prompt t
   ;; Use fuzzy matching without space between letters, except for
   ;; Swiper (search)
   ivy-re-builders-alist
   '((swiper . ivy--regex-plus)
     (t      . ivy--regex-fuzzy))
   ivy-initial-inputs-alist nil)
#+END_SRC

Ivy-resume with ~C-c c-r~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-r") 'ivy-resume)
#+END_SRC

Cycle through buffers with =Ivy= with ~C-TAB~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<C-tab>") 'ivy-switch-buffer)
#+END_SRC

Answer with y/n instead of yes/no:

#+BEGIN_SRC emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

SMEX (`M-X`) states are saved in the =cache= subfolder:

#+BEGIN_SRC emacs-lisp
  (setq smex-save-file (concat user-emacs-directory "cache/smex-items"))
#+END_SRC

Use Counsel for enhanced Find File (~C-x C-f~ or ~C-x C-o~ in other
window):

#+BEGIN_SRC emacs-lisp
  (setq counsel-find-file-at-point t)
  (global-set-key (kbd "C-x C-o") 'find-file-other-window)
  ;; (global-set-key (kbd "<f1> f") 'counsel-describe-function)
  ;; (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
  ;; (global-set-key (kbd "<f1> l") 'counsel-find-library)
  ;; (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
  ;; (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
#+END_SRC

Use Swiper for enhanced search with ~C-s~ (Swiper comes with Counsel
as a dependency):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-s") 'swiper)
#+END_SRC

Counsel interface to shell and system tools:

#+BEGIN_SRC emacs-lisp
  ;; (global-set-key (kbd "C-c g") 'counsel-git)
  ;; (global-set-key (kbd "C-c j") 'counsel-git-grep)
  ;; (global-set-key (kbd "C-c k") 'counsel-ag)
  ;; (global-set-key (kbd "C-x l") 'counsel-locate)
  ;; (global-set-key (kbd "C-S-o") 'counsel-rhythmbox)
#+END_SRC





* Buffer editing

Never use Tabs when indenting, use spaces instead:

#+BEGIN_SRC emacs-lisp
  (setq-default indent-tabs-mode nil)
#+END_SRC

[[https://www.gnu.org/software/emacs/manual/html_node/emacs/CUA-Bindings.html][CUA mode]] (~C-x~, ~C-c~, ~C-v~, and ~C-z~; rectangle selection with
~C-S-Ret~; global mark with ~C-S-Space~; delete-selection mode):

#+BEGIN_SRC emacs-lisp
  (setq cua-rectangle-mark-key (kbd "C-S-RET"))
  (cua-mode 1)
  (global-set-key [(ctrl shift return)] 'cua-set-rectangle-mark)
#+END_SRC

Electric pair mode: Automatically close double quotes, back quotes,
parentheses, square brackets and curly brackets:

#+BEGIN_SRC emacs-lisp
  (electric-pair-mode 1)
  (setq electric-pair-pairs '(
                              (?\" . ?\")
                              (?\` . ?\`)
                              (?\( . ?\))
                              (?\[ . ?\])
                              (?\{ . ?\})
                              ) )
#+END_SRC

Show matching parentheses and other characters (without any delay):

#+BEGIN_SRC emacs-lisp
  (setq show-paren-delay 0)
  (show-paren-mode 1)
#+END_SRC

[[https://github.com/Malabarba/aggressive-indent-mode][Aggressive indent]] in Programming mode to indent automatically all
blocks when a part is moved (add modes to
=aggressive-indent-excluded-modes= to NOT start aggressive indent in
this mode) [NOTE: Disabled because of bugs with Polymode!]:

#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'prog-mode-hook #'aggressive-indent-mode)
#+END_SRC

[[https://github.com/anler/centered-window-mode/][Center text]] when there is only one window (in the width of the frame):

#+BEGIN_SRC emacs-lisp
  (centered-window-mode t)
#+END_SRC

Automatically break long lines (by default after 70 characters, as set
in the variable =fill-column=): 

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+END_SRC

Consider CamelCase as two words in programming modes (but don't show
it with "," in the mode line):

#+BEGIN_SRC emacs-lisp
  (add-hook 'prog-mode-hook 'subword-mode)
  (dim-minor-name 'subword-mode "" 'subword)
#+END_SRC

Cycle between snake_case, lowerCamelCase and kebab-case using ~C-c
C-u~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-u") 'string-inflection-custom-cycle)
  (setq string-inflection-skip-backward-when-done t)

  (defun string-inflection-custom-cycle ()
    "foo_bar => fooBar => foo-bar => foo_bar"
    (interactive)
    (string-inflection-insert
     (string-inflection-custom-cycle-function (string-inflection-get-current-word))))

  (fset 'string-inflection-cycle 'string-inflection-custom-cycle)

  (defun string-inflection-custom-cycle-function (str)
    "foo_bar => fooBar => foo-bar => foo_bar"
    (cond
     ((string-inflection-underscore-p str)
      (string-inflection-lower-camelcase-function str))
     ((string-inflection-lower-camelcase-p str)
      (string-inflection-kebab-case-function str))
     (t
      (string-inflection-underscore-function str))))
#+END_SRC

Complete anything (=company=), with ~TAB~ (=(kbd "TAB")= for terminal;
=[tab]= for graphical mode) to complete immediately, no delay and
aggressive completion:

#+BEGIN_SRC emacs-lisp
  (add-hook 'after-init-hook 'global-company-mode)
  (dim-minor-name 'company-mode "" 'company)
  (with-eval-after-load 'company
    (define-key company-active-map (kbd "TAB") #'company-complete-common)
    (define-key company-active-map [tab] #'company-complete-common))
  (setq company-idle-delay 0
        company-echo-delay 0
        company-dabbrev-downcase nil
        company-minimum-prefix-length 2
        company-selection-wrap-around t
        company-transformers '(company-sort-by-occurrence
                               company-sort-by-backend-importance))
#+END_SRC

Multiple cursors (=multiple-cursors=), choices are saved in the
=cache= folder; ~F11~ to have multiple cursors in all lines of a
region; ~C-F11~ tries to be smart about marking everything you want
(can be pressed multiple times); ~C-S-F11~ marks the next item like
the selection (use then arrows to select more/less):

#+BEGIN_SRC emacs-lisp
  (setq mc/list-file (concat user-emacs-directory "cache/mc-lists.el"))
  (global-set-key [(f11)] 'mc/edit-lines)
  (global-set-key [(ctrl f11)] 'mc/mark-all-dwim)
  (global-set-key [(ctrl shift f11)] 'mc/mark-more-like-this-extended)
  (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click)
#+END_SRC

Magnar Sveen wrote a [[https://github.com/magnars/.emacs.d/blob/master/defuns/lisp-defuns.el][very useful function]] to evaluate and directly
replace a Lisp expression. For instance, evaluating =(+ 1 2)= replaces
the expression by =3= (works in any buffer). It is bound to ~C-x C-y~:

#+BEGIN_SRC emacs-lisp
  (load-library "sexp-eval-and-replace")
  (global-set-key (kbd "C-x C-y") 'sexp-eval-and-replace)
#+END_SRC

[[https://github.com/yewton/sudden-death.el][Sudden death]]! (with ~C-c C-d~):

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c C-d") 'sudden-death)
#+END_SRC


** Spell check and syntax check

Emacs built-in spell check package is Ispell. A good approach is to
use =Hunspell= as the spell check engine (needs to be installed), with
"en_US" as the default dictionary (~C-S-F12~ to change
dictionary). =Flyspell= (spell check on the fly) is enabled by default
in all text files (~C-F12~ to toggle Flyspell), and in programming
mode (only in the comments) in programming files. ~F12~ (or middle
click) opens the list of correction suggestions:

#+BEGIN_SRC emacs-lisp
  (setq ispell-program-name "hunspell"
        ispell-local-dictionary "en_US")

  (add-hook 'text-mode-hook 'turn-on-flyspell)
  (add-hook 'prog-mode-hook 'flyspell-prog-mode)

  (global-set-key [f12] 'flyspell-correct-word-before-point)
  (global-set-key [C-f12] 'flyspell-mode) ; + flyspell-buffer when on!
  (global-set-key [C-S-f12] 'ispell-change-dictionary)
#+END_SRC

Syntax can be checked with the [[https://github.com/flycheck/flycheck][Flycheck]] package (need to install
=lintr= package for R); I recommend to turn it on on demand (=M-x
flycheck-mode=).


** File saving

Default language environment is UTF-8:

#+BEGIN_SRC emacs-lisp
  (setq current-language-environment "UTF-8")
#+END_SRC

Don't lock files and accepts simultaneous editing (no [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Interlocking.html][interlocking]],
which creates tmp lockfiles):

#+BEGIN_SRC emacs-lisp
  (setq create-lockfiles nil)
#+END_SRC

[[http://www.emacswiki.org/emacs/AutoSave][Auto-save]] in =~/.emacs.d/save= (after 10 seconds or 100 characters):

#+BEGIN_SRC emacs-lisp
  (setq
   auto-save-file-name-transforms `((".*" ,"~/.emacs.d/save/\\1" t))
   auto-save-list-file-name (concat user-emacs-directory "cache/save-list")
   auto-save-interval 100
   auto-save-timeout 10)
#+END_SRC

[[http://www.emacswiki.org/emacs/BackupDirectory][Backups]] in =~/.emacs.d/save= (a backup happens everytime a file is
open, and then on each subsequent saves). Copy backup files, keep a
versioned (numbered) backup, and only keep the first 2 and last 2
versions of each backup:

#+BEGIN_SRC emacs-lisp
  (defvar save-dir (concat user-emacs-directory "cache/save"))
  (setq
   backup-directory-alist (list (cons "." save-dir))
   backup-by-copying t
   version-control t
   kept-new-versions 2
   kept-old-versions 2
   delete-old-versions t)
                                          #+END_SRC

Abbreviations ([[https://www.gnu.org/software/emacs/manual/html_node/emacs/Abbrevs.html][Abbrevs]]) are a way to save keystrokes by expanding
words into longer text. Since I don't use it, it gets slightly in the
way. I tell Emacs to save abbreviations in the cache directory
silently:

#+BEGIN_SRC emacs-lisp
  (setq abbrev-file-name (concat user-emacs-directory "cache/abbrev_defs"))
  (setq save-abbrevs 'silently)
#+END_SRC


* Utilities


** File manager

=Dired= (launched in current directory with with ~F6~) list
directories first, refresh automatically directories, intelligently
guess where to copy (other window), and does not ask for confirmation
for recursive copies and deletes. Switch to WDired mode (to 'write'
file names) with ~C-F6~, go to bookmarks with ~$~, insert/remove
subdirectories with ~i~ and ~<backspace>~ (with [[https://github.com/Fuco1/dired-hacks#dired-subtree][Dired-subtree]]),
dynamically filter files and folders with ~/~ (part of [[https://github.com/Fuco1/dired-hacks#dired-narrow][Dired-narrow]]),
and =ediff= two marked files with ~e~ (with =dired-ediff-files=):

#+BEGIN_SRC emacs-lisp
  (setq
   dired-listing-switches "-aBhl  --group-directories-first"
   ;; dired-omit-files "^\\.$"
   dired-auto-revert-buffer t
   dired-dwim-target t
   dired-recursive-copies (quote always)
   dired-recursive-deletes (quote always))
  (global-set-key (kbd "<f6>")
                  (lambda ()
                    (interactive)
                    (dired ".")))
  (add-hook 'dired-mode-hook 'auto-revert-mode)
  (eval-after-load "dired"
    '(progn
       (load-library "dired-ediff-files")
       (hl-line-mode)
       (define-key dired-mode-map [(ctrl f6)] #'dired-toggle-read-only)
       (define-key dired-mode-map "i" 'dired-subtree-insert)
       (define-key dired-mode-map (kbd "<backspace>") 'dired-subtree-remove)
       (define-key dired-mode-map "/" 'dired-narrow)
       (define-key dired-mode-map "e" 'dired-ediff-files)
       ))
#+END_SRC

In addition, [[https://www.emacswiki.org/emacs/DiredPlus][Dired+]] allows to use a single buffer for visited folders
with Dired (as well as providing richer highlighting including
mouse-over highlighting, and wrap around navigation), and we want the
Dired buffer to start with details displayed. [[https://gitlab.com/xuhdev/dired-quick-sort][dired-quick-sort]] allows
to interactively sort Dired buffers:

#+BEGIN_SRC emacs-lisp
  (setq diredp-hide-details-initially-flag nil)
  (diredp-toggle-find-file-reuse-dir 1)
  (dired-quick-sort-setup)
#+END_SRC

Remove =.= from the list of files/folders (and be silent about it):

#+BEGIN_SRC emacs-lisp
  (setq-default dired-omit-files-p t)
  (setq
   dired-omit-verbose nil
   dired-omit-files "^\\.$"
   dired-omit-extensions nil)
#+END_SRC

Use [[https://github.com/jaypei/emacs-neotree][NeoTree]] to have a tree explorer on the side (bound to
~F5~):

(to be replaced by =[[https://github.com/sebastiencs/sidebar.el][sidebar]]= when it reaches MELPA)

#+BEGIN_SRC emacs-lisp
  (setq neo-theme 'ascii)
  (global-set-key [(f5)] 'neotree-toggle)
#+END_SRC


#+BEGIN_SRC emacs-lisp
  ;; (add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
#+END_SRC


TRAMP history of connections in =.emacs.d/cache/tramp=, make
completion faster, shell history in standard location
("$HOME/.sh_history"), backups of remote files disabled, and just to
be sure, version control is disabled on remote files (although VC is
already disable entirely below:

#+BEGIN_SRC emacs-lisp
  (setq
   tramp-persistency-file-name (concat user-emacs-directory "cache/tramp")
   tramp-completion-reread-directory-timeout nil
   tramp-histfile-override nil
   )
  (add-to-list 'backup-directory-alist
               (cons tramp-file-name-regexp nil))
  (setq vc-ignore-dir-regexp
        (format "\\(%s\\)\\|\\(%s\\)"
                vc-ignore-dir-regexp
                tramp-file-name-regexp))
#+END_SRC


** GIT

[[https://magit.vc/][Magit]] is a interface to Git completely integrated to Emacs. Once
installed, it pretty much works out of the box, there are just a
couple of settings to make it even smoother (remove Git from the list
of backends handled by Emacs version control; use Ivy to complete;
links to Git-man; automatically refresh the repository's status after
file save). We also bound Magit to ~F8~, and integrate Git-flow to
Magit (=magit-gitflow=, started with ~C-f~ from within Magit):

#+BEGIN_SRC emacs-lisp
  (load-library "magit-repository-directories")
  (shell-command "git config --global status.showUntrackedFiles all") ; List files in folders
  (global-set-key [(f8)] 'magit-status)
  ;; (setq vc-handled-backends (delq 'Git vc-handled-backends))
  (setq vc-handled-backends nil)
  (setq
   magit-completing-read-function 'ivy-completing-read
   magit-view-git-manual-method 'man
   magit-refs-show-commit-count 'all)
  (with-eval-after-load 'magit
    (load-library "magit-ls-files")

    ;; (setq magit-repolist-columns
    ;;       '(("Name" 25 magit-repolist-column-ident nil)
    ;;         ("Version" 25 magit-repolist-column-version nil)
    ;;         ("D" 1 magit-repolist-column-dirty nil)
    ;;         ("B<U" 3 magit-repolist-column-unpulled-from-upstream
    ;;          ((:right-align t)))
    ;;         ("B>U" 3 magit-repolist-column-unpushed-to-upstream
    ;;          ((:right-align t)))
    ;;         ("Path" 99 magit-repolist-column-path nil)))
          
    ;; (setcdr (cdr magit-repolist-columns)
    ;;         (cons '("D" 1 magit-repolist-column-dirty nil)
    ;;               (cddr magit-repolist-columns)))
    
    (define-key magit-mode-map (kbd "K") 'magit-ls-files)
    (add-hook 'after-save-hook 'magit-after-save-refresh-status))
  (add-hook 'magit-mode-hook 'turn-on-magit-gitflow)
#+END_SRC


** Shell

Emacs provide different possibilities to embed a Shell (for instance,
~M-x shell~, ~M-x ansi-term~), with different advantages and
drawbacks. Here I setup Eshell (the Emacs shell, ~M-x eshell~), with
short names to [[https://www.emacswiki.org/emacs/EshellRedirection][redirect to buffers]] and completion that ignores
case. [[https://github.com/xuchunyang/eshell-git-prompt][eshell-git-prompt]] enables detection of Git repositories and
brings a nice powerline:

#+BEGIN_SRC emacs-lisp
  (setq
   eshell-buffer-shorthand t
   eshell-cmpl-ignore-case t)
  (eshell-git-prompt-use-theme 'powerline)
#+END_SRC

In Shell, use ~C-l~ to send commands directly to the subshell (useful
for =screen= for instance):

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'shell
    (define-key shell-mode-map (kbd "C-l") (lambda (seq) (interactive "k") (process-send-string nil seq))))
#+END_SRC

Finally, a function =shell-xterm= (~C-F8~) launches a shell with
clearing capabilities (needed for =screen=):

#+BEGIN_SRC emacs-lisp
  (load-library "shell-xterm")
  (global-set-key [(ctrl f8)] 'shell-xterm)
#+END_SRC


** PDF

Use PDF tools to view PDF (=libpoppler-glib-dev= required):

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.pdf" . pdf-tools-install))
  (setq-default pdf-view-display-size 'fit-page) ; Start PDF in full page
  (setq pdf-annot-activate-created-annotations t) ; Automatically annotate highlights
#+END_SRC

From within a PDF, use ~P~ to fit the zoom to the page; ~H~ to the
height, ~W~ to the width; ~g~ refreshes (reverts) the PDF; ~h~ opens
the help of PDF tools. Highlight: select text with the mouse, then
~C-c C-a h~, annotate, then ~C-c C-c~ to commit; ~C-c C-a t~ and then
mouse click to add a text note somewhere to the pdf page; ~C-c C-a o~
to strike-through text, and ~C-c C-a D~ and then click to delete an
annotation. List annotations with ~C-c C-a l~. Don't forget to save
the PDF (~C-x C-s~)!


** EWW web browser

Emacs comes with a built-in web browser: EWW. Use ~M-x eww~ to run it;
~<backspace>~ goes to previous page; ~f~ opens the page in external
browser (Firefox for me).

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'eww
    (define-key eww-mode-map "f" 'eww-browse-with-external-browser)
    (define-key eww-mode-map [backspace] 'eww-back-url))
#+END_SRC


* Major modes


** YAML

=YAML-mode= for YAML headers/files:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode))
#+END_SRC


** Org

Org mode comes with its own keybindings, ([[http://orgmode.org/manual/Conflicts.html][which can easily conflict
with other settings]]).

#+BEGIN_SRC emacs-lisp
  (setq org-replace-disputed-keys t)
  #+END_SRC

Make nice UTF-8 bullet points:

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+END_SRC

# [not working]
#
# To make windmove active in locations where Org mode does not have
# special functionality on M-<cursor>:
#
# #+BEGIN_SRC emacs-lisp
# (add-hook 'org-metaup-final-hook 'windmove-up)
# (add-hook 'org-metaleft-final-hook 'windmove-left)
# (add-hook 'org-metadown-final-hook 'windmove-down)
# (add-hook 'org-metaright-final-hook 'windmove-right)
# #+END_SRC


Table of contents with [[https://github.com/snosov1/toc-org][Toc-Org]] (just add a =:TOC:= tag with 
~C-c C-q~ in the first header, and the table of contents will be
automatically updated on file save):

#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook 'toc-org-enable) 
#+END_SRC


Org-babel can recognize code blocks [[http://orgmode.org/manual/Languages.html][from many different languages]] (Lisp,
Bash, R, etc.) and provides a way to edit them in their respective
mode (~C-c '~; and same keybinding to close). However,  =polymode=
provides an even better integration directly in the Org file. We load
a few languages:

#+BEGIN_SRC emacs-lisp 
  (with-eval-after-load 'org
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((css . t)
       (ditaa . t)
       (emacs-lisp . t)
       (latex . t)
       (lilypond . t)
       (org . t)
       (sh . t)
       (sql . t)
       (R . t))))
  #+END_SRC

Give the correct path to the Ditaa java library:

#+BEGIN_SRC emacs-lisp
  (setq org-ditaa-jar-path (expand-file-name "/usr/share/ditaa/ditaa.jar"))
#+END_SRC


# ;; Keeping notes and TODO lists: org-mode
# (use-package org
# 	     ;; See config at: http://writequit.org/org/settings.html#sec-1-6x
# 	     :mode (("\\.org$" . org-mode))	; Activate Org for .org files
# 	     :bind (("C-c l" . org-store-link)
# 		    ("C-c a" . org-agenda)
# 		    ("C-c b" . org-iswitchb)
# 		    ("C-c c" . org-capture)
# 		    ("C-c M-p" . org-babel-previous-src-block)
# 		    ("C-c M-n" . org-babel-next-src-block)
# 		    ("C-c S" . org-babel-previous-src-block)
# 		    ("C-c s" . org-babel-next-src-block)
# 		    ([(f6)] . org-todo-list) ; Global TODO list
# 		    ([(control f6)] . org-ctrl-c-ctrl-c) ; C-c C-c 
# 		    ([(f7)] . org-insert-todo-here) ; Insert TODO at point
# 		    ([(control f7)] . org-todo)	 ; Rotate TODO state
# 		    ([(control shift f7)] . org-show-todo-tree)	 ; Shows TODOs in current buffer
# 		    ;; (:map org-mode-map		  ; Edit code block in its specific mode
# 		    ;;       ([(control shift f6)] . org-edit-special))
# 		    ;; (:map org-src-mode-map		; Exit code block editing
# 		    ;;       ([(control shift f6)] . org-edit-srv-exit))
# 		    )
# 	     :config
# 	     (progn
# 	       (org-defkey org-mode-map [(ctrl shift f6)] 'org-edit-special) ; Edit code block in its specific mode
# 	       (org-defkey org-src-mode-map [(ctrl shift f6)] 'org-edit-src-exit) ; Exit code block editing
# 	       (setq
# 		;; Display
# 		org-hide-emphasis-markers t	; Hide markers
# 		org-ellipsis "⤵"			; Downward-pointing arrow instead of the usual …
# 		org-src-fontify-natively t		; Use syntax highlighting in source blocks
# 		org-src-tab-acts-natively t	; Make TAB act like the language's major mode in source blocks
# 		;; org-startup-folded 'overview ; Start with top level headlines visible
# 		org-display-inline-images t	; Enable inline images
# 		;; org-directory 			; Where Org checks for files
# 		;; org-archive-location		; Folder for archiving an entry
# 		org-agenda-files '("~/.emacs.d/org") ; List of files for agenda/TODOs
# 		;; org-support-shift-select 'always	; Allows shift selection
# 		org-return-follows-link t		; Follow links by pressing ENTER on them
# 					; (alternative to C-c C-o / M-x org-open-at-point)
# 		org-replace-disputed-keys t	; Conflicting keys
# 					; http://orgmode.org/manual/Conflicts.html
# 		org-default-notes-file (concat org-directory "/notes.org")
# 					;
# 		org-log-done t		   ; Insert dates for changes in TODOs
# 		org-todo-keywords ; TODO keywords: http://orgmode.org/manual/TODO-extensions.html#TODO-extensions
# 					; http://orgmode.org/guide/Tracking-TODO-state-changes.html#Tracking-TODO-state-changes
# 					; @ requires a note
# 					; ! puts a timestamp (not necessary for DONE)
# 		;; '((sequence "SOMEDAY(s)" "NOW(n)" "LATER(l)" "WAITING(w@/!)" "NEEDSREVIEW(n@/!)" "|" "DONE(d)")
# 		'((sequence "SOMEDAY(s)" "NOW(n!)" "LATER(l)" "PROJECT(p)" "CANCELLED(c@/!)" "|" "DONE(d)"))
# 		;; (sequence "REPORT(r)" "BUG(b)" "KNOWNCAUSE(k)" "|" "FIXED(f)"))
# 		org-todo-keyword-faces		; ORG faces
# 		'(("SOMEDAY" :foreground "purple" :weight bold)
# 		  ("NOW" :foreground "orange" :weight bold)
# 		  ("LATER" :foreground "forest green" :weight bold)
# 		  ("PROJECT" :foreground "blue" :weight bold)
# 		  ("CANCELLED" :foreground "red" :weight bold)
# 		  ("DONE" :foreground "gray" :weight bold))
# 		org-use-fast-todo-selection t	; Menu with selection of TODO keywords
# 		org-enforce-todo-dependencies t	; Parent can't be marked as done unless all children are done
# 		)
# 	       (defun org-summary-todo (n-done n-not-done)
# 		 "Switch entry to DONE when all subentries are done, to SOMEDAY otherwise."
# 		 (let (org-log-done org-log-states)   ; turn off logging
# 		   (org-todo (if (= n-not-done 0) "DONE" "SOMEDAY"))))
# 	       ;; Insert TODO at point
# 	       (load-library "org-insert-todo-here")
# 	       ;; DISPLAY
# 	       (font-lock-add-keywords 'org-mode	; Real bullets
# 				       '(("^ +\\([-*+]\\) "
# 					  (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
# 	       ;; Nice headers
# 	       (let* ((variable-tuple (cond ((x-list-fonts "Source Sans Pro") '(:font "Source Sans Pro"))
# 					    ((x-list-fonts "Lucida Grande")   '(:font "Lucida Grande"))
# 					    ((x-list-fonts "Verdana")         '(:font "Verdana"))
# 					    ((x-family-fonts "Sans Serif")    '(:family "Sans Serif"))
# 					    (nil (warn "Cannot find a Sans Serif Font.  Install Source Sans Pro."))))
# 		      (base-font-color     (face-foreground 'default nil 'default))
# 		      (headline           `(:inherit default :weight bold :foreground ,base-font-color)))
# 		 (custom-theme-set-faces 'user
# 					 `(org-level-8 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-7 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-6 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-5 ((t (,@headline ,@variable-tuple))))
# 					 `(org-level-4 ((t (,@headline ,@variable-tuple :height 1.1))))
# 					 `(org-level-3 ((t (,@headline ,@variable-tuple :height 1.25))))
# 					 `(org-level-2 ((t (,@headline ,@variable-tuple :height 1.5))))
# 					 `(org-level-1 ((t (,@headline ,@variable-tuple :height 1.75))))
# 					 `(org-document-title ((t (,@headline ,@variable-tuple :height 1.5 :underline nil))))))
# 	       (use-package org-bullets	; Header bullets
# 					; https://github.com/sabof/org-bullets
# 			    :config
# 			    (progn
# 			      (require 'org-bullets)		; 
# 			      (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))))
# 	       ))


** LaTeX

The main package for LaTeX in Emacs is AUCTeX. In this configuration,
AUCTeX integrates RefTeX (references), LatexMk (compilation) and PDF
Tools (visualization). Note that compilation logs are not shown by
default (use ~C-c C-l~ to see them, or add =(setqTeX-show-compilation
t)= in the =LaTeX-mode-hook=). We start by configuring the LaTeX mode
(notably RefTeX, fold LaTeX environments [F], Math mode [M],
compilation as PDF [P], forward and inverse search [S]):

#+BEGIN_SRC emacs-lisp
  (setq TeX-parse-self t                ; Enable parse on load.
        TeX-auto-save t                 ; Enable parse on save.
        TeX-source-correlate-mode t	; Forward and inverse search with Synctex
        TeX-clean-confirm nil ; Don't ask for confirmation to clean intermediary files
        reftex-plug-into-AUCTeX t       ; Plug RefTeX to AUCTeX
        reftex-default-bibliography '("/home/mathieu/Work/Biblio/BiblioMB.bib") ; Default bib
        TeX-auto-untabify t             ; Replace Tabs by spaces on save
        )
  (add-hook 'LaTeX-mode-hook 
            (lambda ()
              (TeX-global-PDF-mode t)   ; Compile as PDF
              (LaTeX-math-mode)         ; Math mode
              (turn-on-reftex)          ; RefTeX on
              (outline-minor-mode 1)	; Fold LaTeX sections
              (TeX-fold-mode 1)         ; Fold LaTeX environments
              ))
  (dim-minor-name 'reftex-mode "" 'reftex)
  (dim-minor-name 'outline-minor-mode "" 'outline)
#+END_SRC

The compilation by LatexMk (a single call to perform all necessary
LaTeX/BibTeX compilations) is performed through the [[https://github.com/tom-tan/auctex-latexmk][auctex-latexmk]]
package, which allows to have LatexMk as the default engine for LaTeX compilation:

#+BEGIN_SRC emacs-lisp
  (setq auctex-latexmk-inherit-TeX-PDF-mode t) ; LaTeXMk inherits PDF mode 
  (with-eval-after-load "tex"
    (auctex-latexmk-setup))
  (add-hook 'TeX-mode-hook (lambda () (setq TeX-command-default "LatexMk")))
#+END_SRC

We also enable completion for LaTeX commands using Company:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load "tex"
    (company-auctex-init)
    )
#+END_SRC

Finally, we enable the use of PDF tools to visualize the resulting PDF
and refresh it automatically:

#+BEGIN_SRC emacs-lisp
  (setq TeX-view-program-selection '((output-pdf "PDF Tools"))
        TeX-source-correlate-start-server t)
  (add-hook 'TeX-after-compilation-finished-functions #'TeX-revert-document-buffer)
#+END_SRC

# ;; Clean up intermediary files with LaTeXmk and Beamer
# (add-to-list 'LaTeX-clean-intermediate-suffixes "\\.fdb_latexmk" t)
# (add-to-list 'LaTeX-clean-intermediate-suffixes "\\.vrb" t)

# ;; Pour utiliser le langage de babel en mode LaTeX avec flyspell-babel :
# ;; http://www.dur.ac.uk/p.j.heslin/Software/Emacs/
# ;; FAIT PLANTER FLYSPELL ! 
# ;; (autoload 'flyspell-babel-setup "flyspell-babel")
# ;; (add-hook 'LaTeX-mode-hook 'flyspell-babel-setup)
# ;; (setq flyspell-babel-delay 1)  ; Delai avant "reparsing" du block. Ça marche ça ?
# ;; (setq flyspell-babel-verbose t)
# ;; (setq flyspell-babel-to-ispell-alist
# ;;       '(("french" "fr_FR")
# ;; 	("english" "en")
# ;; 	("american" "en_US")
# ;; 	("canadian" "en_CA")
# ;; 	("british" "en_GB")))
# ;; Comment avoir à nouveau le \og quand on est en français et qu'on tape " ?


*** BibTeX

BibTex is managed through =[[https://github.com/tmalsburg/helm-bibtex][ivy-bibtex]]=. It needs to know the location
of the main bibliography (can handle several), where the PDF are
stored, 
# the additional field =File= for additional attached files,
and the list of potential extensions used there:

#+BEGIN_SRC emacs-lisp
  (setq
   bibtex-completion-bibliography '("/home/mathieu/Work/Biblio/BiblioMB.bib")
   bibtex-completion-library-path '("/home/mathieu/Work/Biblio/PDF/")
   ;; bibtex-completion-pdf-field "File"
   bibtex-completion-pdf-extension '(".pdf" ".djvu" ".ps")
   )
#+END_SRC

By default a PDF will be open in Emacs (with =pdf-tools=);
alternatively, Evince can also be used:

#+BEGIN_SRC emacs-lisp :tangle no
  (setq bibtex-completion-pdf-open-function
        (lambda (fpath)
          (call-process "evince" nil 0 nil fpath)))
#+END_SRC

Finally, =ivy-bibtex= is bound to ~C-c b~:

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c b") 'ivy-bibtex)
#+END_SRC

In BibTeX mode (e.g. when opening and editing the main bibliography),
new entries are created with ~C-c C-e~, like ~C-c C-e C-a~ for
articles, ~C-c C-e C-t~ for technical reports, and ~C-c C-e C-b~ for
books.  When the point is on an entry, pressing ~C-j~ moves to the next
field.  ~C-c C-c~ checks and cleans the entry at point (including
generation of key if it does not exist, alignment, etc.). If necessary
~C-c C-q~ formats the entry nicely.  Full documentation for BibTex
mode is available [[http://www.jonathanleroux.org/bibtex-mode.html][here]].

#+BEGIN_SRC emacs-lisp
  (defun current-date ()
    (format-time-string "%Y.%m.%d"))    
  (setq
   bibtex-entry-format '(opts-or-alts required-fields numerical-fields whitespace realign unify-case sort-fields) ; Clean optional fields, remove brackets around numerical fields, remove white space, realign, unify case of entry type and fields, sort fields in predefined order
   bibtex-align-at-equal-sign t    ; Also align = sign
   bibtex-autokey-name-year-separator "_" ; Underscore between Name and Year
   bibtex-autokey-year-length 4           ; Year as YYYY
   bibtex-autokey-name-case-convert-function 'capitalize ; Name with capitale
   bibtex-autokey-titlewords 0                           ; No title
   bibtex-autokey-titleword-length 0                     ; No title
   bibtex-autokey-edit-before-use nil                    ; Don't edit before use
   bibtex-user-optional-fields '( ; Additional fields: DOI, url, date, owner, abstract
                                 ("doi" "DOI for the entry")
                                 ("url" "URL for the entry")
                                 ("timestamp" "Time the entry was created" current-date)
                                 ("owner" "Owner of the entry" user-login-name)
                                 ("abstract" "Abstract for the entry"))
   )  
#+END_SRC


** Markdown

[[http://jblevins.org/projects/markdown-mode/][Markdown-mode]] is used to edit Markdown files (=.md= or =.markdown=)
and is loaded automatically. We simply enable Math and Imenu:

# BUG with markdown-toc; see bug report with M-x markdown-toc-bug-report
# 
# , and integrate
# =[[https://github.com/ardumont/markdown-toc][markdown-toc]]= (type ~M-x markdown-toc-generate-toc~ to generate Table
# of contents at point):

#+BEGIN_SRC emacs-lisp
  (setq markdown-enable-math t)
  (add-hook 'markdown-mode-hook 
            (lambda ()
              (imenu-add-menubar-index)))
#+END_SRC


** ESS

ESS to use R, edit R script, edit R documentation (Roxygen) and
prepare packages. ESS is simply loaded with:

R is not a =prog-mode=, so it needs its own settings in the ESS hook.

[[https://github.com/mattfidler/ess-smart-underscore.el][ESS Smart Underscore]]


#+BEGIN_SRC emacs-lisp
  (require 'ess-site)
  (setq
   ess-default-style 'OWN
   inferior-ess-same-window nil         ; Run R in inferior window
   ess-ask-for-ess-directory nil ; Use current directory as working directory
   inferior-R-args "--quiet --no-save"  ; No save on exit
   ess-nuke-trailing-whitespace-p t     ; remove trailing spaces
   comint-scroll-to-bottom-on-input t ; Always scroll to the end of the R buffer
   comint-scroll-to-bottom-on-output t ; Scroll automatically when output reaches bottom
   ;; comint-move-point-for-output t
   ess-eval-visibly 'nowait             ; Does not wait for R
   ess-swv-processor 'knitr ; Use knitr instead of Sweave as ESS processor
   ess-roxy-fontify-examples t ; Syntax highlighting in Roxygen examples
   ess-swv-plug-into-auctex-p t ; Add integration of Sweave/Kniter into AUCTeX
   ess-use-ido nil              ; ESS should not use IDO for completion
   )
  (custom-set-variables
   '(ess-own-style-list
     (quote
      ((ess-indent-offset . 4)
       (ess-offset-arguments . prev-line)
       (ess-offset-arguments-newline . prev-line)
       (ess-offset-block . prev-line)
       (ess-offset-continued . straight)
       (ess-align-nested-calls)
       (ess-align-arguments-in-calls)
       (ess-align-continuations-in-calls . prev-line)
       (ess-align-blocks control-flow)
       (ess-indent-from-lhs)
       (ess-indent-from-chain-start)
       (ess-indent-with-fancy-comments . t)))))  
#+END_SRC

# (defcustom ess-own-style-list (cdr (assoc 'RRR ess-style-alist))
#   "Indentation using R parser rules"
#   :group 'ess-edit
#   :type 'alist
#   :initialize 'custom-initialize-set
#   :set (lambda (symbol value)
#          (set symbol value)
#          (ess-add-style 'R value)))

#+BEGIN_SRC emacs-lisp
  (add-hook 'ess-mode-hook 
            (lambda ()
              (flyspell-prog-mode)
              (require 'ess-smart-underscore) 
              (highlight-indent-guides-mode) ; Highlight indentation using
                                        ; 'highlight-indent-guides'
              (subword-mode) ; Consider CamelCase as two words             
              (hs-org/minor-mode) 
              (local-set-key [(ctrl shift f10)] 'hs-toggle-hiding)
              ;; (aggressive-indent-mode)
              ;; (myindent-ess-hook)
              (add-hook 'local-write-file-hooks ; Remove trailing white spaces on save
                        (lambda ()
                          (ess-nuke-trailing-whitespace)))
              ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'ess-R-post-run-hook 
            'ess-execute-screen-options) ; Sets R option "width" to the width of the R 
                                        ; buffer on startup
#+END_SRC

Use the R parser (ess-indent-region-as-r) or formatR
(ess-indent-region-with-formatr) to format R code. The later
is bound to C-M-\ ou 'M-x indent-region'.

#+BEGIN_SRC emacs-lisp  
  (add-hook 'ess-mode-hook
            (lambda ()
              (load-library "ess-indent-region-r")
              (set (make-local-variable 'indent-region-function)
                   'ess-indent-region-with-formatr)))
#+END_SRC

An alternative is to use Google's R source code formatter
([[https://github.com/google/rfmt][rfmt]]), but it only works for an entire
buffer (bound to ~C-x C-i~):

#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "/home/mathieu/.R-site/site-library/rfmt/elisp")
  (add-hook 'ess-mode-hook
            (lambda ()
              (setq rfmt-executable "/home/mathieu/.R-site/site-library/rfmt/python/rfmt.py")
              (load-library "rfmt-emacs")
              (local-set-key (kbd "C-x C-i") 'rfmt-buffer)))
#+END_SRC


In an ESS inferior buffer, use ~C-l~ to send commands directly to the
subshell ([[https://stat.ethz.ch/pipermail/ess-help/2010-July/006202.html][useful for =screen= for instance]]):

#+BEGIN_SRC emacs-lisp
  (define-key inferior-ess-mode-map (kbd "C-l")
    (lambda (seq) (interactive "k")
      (process-send-string nil seq)))
#+END_SRC

In (R)Markdown, add a fenced R code block (~C-return~) or inline R
code (~C-S-return~); render RMarkdown files (using
=rmarkdown::render=) with ~F7~; render RMarkdown files (using
=bookdown::render_book=) with ~C-F7~; :

#+BEGIN_SRC emacs-lisp
  (add-hook 'markdown-mode-hook 
            (lambda ()
              (load-library "ess-rmd-library")
              (local-set-key [C-return] 'ess-rmd-fenced-r-code-block)
              (local-set-key [C-S-return] 'ess-rmd-inline-r-code)
              ))
  (with-eval-after-load 'polymode
    (define-key polymode-mode-map [(f7)] #'ess-rmd-render)
    (define-key polymode-mode-map [(ctrl f7)] #'ess-rmd-bookdown)
    (define-key polymode-mode-map [(shift ctrl f7)] #'ess-md-pandoc))
#+END_SRC

# (defun ess-remote-r ()		; Associate R remote buffer to ESS buffer
    #   (interactive) (ess-remote nil "R"))
# (bind-key "\C-cw" 'ess-execute-screen-options inferior-ess-mode-map) ; C-c w to adjust
# 					; the width of the R buffer
# (bind-keys :map ess-mode-map
             # 	 ("C-c C-x" . ess-eval-chunk)		; C-c C-x to evaluate a R chunk (C-c C-c 
                       # 					; should jump to the next block and C-M-x evaluates
                       # 					; and stays in place)
                       # 	 ([(control shift f8)] . ess-swv-tangle)))) ; C-S-F7 to tangle
# 	 ;; ([(f8)] . ess-display-vignettes)	 ; F8 to display the list of vignettes
# 	 ;; ([(ctrl shift f8)] . ess-remote-r)))) ; C-S-F8 to
# associate R remote buffer to ESS buffer


** SQL

SQL works already well out of the box. I set ~C-return~ to send a
region (if selected) or the current paragraph:

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook
            (lambda ()
              (load-library "sql-library")
              (local-set-key (kbd "<C-return>") 'sql-send-region-or-paragrap)))
#+END_SRC

However, more configuration is required to have a beautiful code and
readable output. First of all, [[https://github.com/bsvingen/sql-indent][sql-indent]] allows to indent correctly
SQL code:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'sql (load-library "sql-indent"))
#+END_SRC

In addition to it, [[https://github.com/Trevoke/sqlup-mode.el][SQL-up]] automatically corrects lower case SQL
reserved names (=SELECT=, =FROM=, etc.). If necessary, it is called
with ~C-c u~ on a region:

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook 'sqlup-mode)
  (add-hook 'sql-interactive-mode-hook 'sqlup-mode)
  (add-hook 'sql-mode-hook
            (lambda ()
              (local-set-key (kbd "C-c u") 'sqlup-capitalize-keywords-in-region)))
#+END_SRC

To make it a step further, [[https://github.com/emacsmirror/format-sql][format-sql]] integrates the Python library of
the same name, and allows to completely format the code in a region
with ~C-M-]~ (an alternative is [[https://github.com/ldeck/SqlBeautify][SQL-beautify]]):

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-mode-hook
            (lambda ()
              (local-set-key (kbd "C-M-]") 'format-sql-region)))
#+END_SRC

# ;; (defun format-sql-region-or-buffer ()
# ;;   "Format SQL for the entire buffer or the marked region"
# ;;   (interactive)
# ;;   (if (use-region-p)
# ;;       (format-sql-bf--apply-executable-to-buffer "format-sql"
# ;;                                                  'format-sql--call-executable
# ;;                                                  t
# ;;                                                  (get-file-type)))
# ;;   (format-sql-bf--apply-executable-to-buffer "format-sql"
# ;;                                              'format-sql--call-executable
# ;;                                              nil
# ;;                                              (get-file-type)))

Set up default PostgreSQL credentials:

#+BEGIN_SRC emacs-lisp
  (setq sql-postgres-login-params
        '((server :default "localhost")
          (port :default 5432)
          (user :default "mathieu")
          (database :default "test")))
#+END_SRC
  
# If several servers:

# #+BEGIN_SRC emacs-lisp :tangle no
#   (setq sql-connection-alist
#         '((server1
#            (sql-product 'postgres)
#            (sql-server "localhost")
#            (sql-port 5432)
#            (sql-database "DATABASE")
#            (sql-user "USER"))
#           (eurodeer
#            (sql-product 'postgres)
#            (sql-server "www.server.org")
#            (sql-port 5432)
#            (sql-database "DATABASE")
#            (sql-user "USER")
#            (sql-password "PASSWORD"))))
# #+END_SRC

# #+BEGIN_SRC emacs-lisp
#   (add-hook 'sql-mode-hook
#             (lambda ()
#               (load-library "sql-connection-alist")))
# #+END_SRC

In the output, we first make sure that lines are not truncated (DOES
NOT WORK):

#+BEGIN_SRC emacs-lisp
  (add-hook 'sql-interactive-mode-hook
            (lambda ()
              ;; (toggle-truncate-lines t)))
              (setq truncate-lines t)))
#+END_SRC

# And that table formating is not off when using =sql-send-region= to
# execute a query in a SQLi buffer (because the column names are printed
# on the same row as the the prompt). We [[https://www.emacswiki.org/emacs/SqlMode][simply add a newline]] before the
# comint output (for all queries, even queries run at the prompt):

# #+BEGIN_SRC emacs-lisp
#   ;; (defvar sql-last-prompt-pos 1
#   ;;   "position of last prompt when added recording started")
#   ;; (make-variable-buffer-local 'sql-last-prompt-pos)
#   ;; (put 'sql-last-prompt-pos 'permanent-local t) 
#   ;; (defun sql-add-newline-first (output)
#   ;;   "Add newline to beginning of OUTPUT for `comint-preoutput-filter-functions'
#   ;;   This fixes up the display of queries sent to the inferior buffer
#   ;;   programatically."
#   ;;   (let ((begin-of-prompt
#   ;;          (or (and comint-last-prompt-overlay
#   ;;                   ;; sometimes this overlay is not on prompt
#   ;;                   (save-excursion
#   ;;                     (goto-char (overlay-start comint-last-prompt-overlay))
#   ;;                     (looking-at-p comint-prompt-regexp)
#   ;;                     (point)))
#   ;;              1)))
#   ;;     (if (> begin-of-prompt sql-last-prompt-pos)
#   ;;         (progn
#   ;;           (setq sql-last-prompt-pos begin-of-prompt)
#   ;;           (concat "\n" output))
#   ;;       output))) 
#   ;; (defun sqli-add-hooks ()
#   ;;   "Add hooks to `sql-interactive-mode-hook'."
#   ;;   (add-hook 'comint-preoutput-filter-functions
#   ;;             'sql-add-newline-first)) 
#   ;; (add-hook 'sql-interactive-mode-hook 'sqli-add-hooks)
# #+END_SRC


** Web

(see =[[https://github.com/hlissner/emacs-counsel-css][counsel-css]]= for integration of CSS selectors with Ivy)

[[http://web-mode.org/][Web-mode]] is a major mode to edit Web files ([s]HTML, CSS, PHP,
etc.). Here is a standard configuration, with auto-pairing, CSS
colorization and a broad list of file extensions and engines
associated to =web-mode=:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.htm?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.shtml?\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.css\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.jinga\\'" . web-mode))
  (setq
   web-mode-enable-auto-pairing t
   web-mode-enable-css-colorization t
   web-mode-engines-alist
   '(("php"    . "\\.phtml\\'")
     ("django" . "\\.jinja\\'")
     ("blade"  . "\\.blade\\.")))
#+END_SRC

Spell check with flyspell can be further [[http://blog.binchen.org/?p=950][integrated to web-mode]]:

#+BEGIN_SRC emacs-lisp
  (defun web-mode-flyspell-verify ()
    (let* ((f (get-text-property (- (point) 1) 'face))
	   rlt)
      (cond
       ;; Check the words with these font faces, possibly.
       ;; this *blacklist* will be tweaked in next condition
       ((not (memq f '(web-mode-html-attr-value-face
                       web-mode-html-tag-face
                       web-mode-html-attr-name-face
                       web-mode-constant-face
                       web-mode-doctype-face
                       web-mode-keyword-face
                       web-mode-comment-face ;; focus on get html label right
                       web-mode-function-name-face
                       web-mode-variable-name-face
                       web-mode-css-property-name-face
                       web-mode-css-selector-face
                       web-mode-css-color-face
                       web-mode-type-face
                       web-mode-block-control-face)))
	(setq rlt t))
       ;; check attribute value under certain conditions
       ((memq f '(web-mode-html-attr-value-face))
	(save-excursion
	  (search-backward-regexp "=['\"]" (line-beginning-position) t)
	  (backward-char)
          (setq rlt (string-match "^\\(value\\|class\\|ng[A-Za-z0-9-]*\\)$"
                                  (thing-at-point 'symbol)))))
       ;; finalize the blacklist
       (t
	(setq rlt nil)))
      rlt))
  (put 'web-mode 'flyspell-mode-predicate 'web-mode-flyspell-verify)
#+END_SRC


** Polymode

[[https://github.com/vitoshka/polymode][Polymode]] allows multiple major modes in the same document (e.g. R +
Markdown in =.Rmd= files). It is setup for Mardown and LateX files
with R:

#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.[rR]md\\'" . poly-markdown+r-mode))
  (add-to-list 'auto-mode-alist '("\\.[sS]nw\\'" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.[rR]nw\\'" . poly-noweb+r-mode))
  (add-to-list 'auto-mode-alist '("\\.org\\'" . poly-org-mode))
#+END_SRC

# Diminish them?
# (with-eval-after-load 'poly-markdown-mode (diminish 'poly-markdown-mode))
# (with-eval-after-load 'poly-markdown+r-mode (diminish 'poly-markdown+r-mode))
# (with-eval-after-load 'poly-noweb+r-mode (diminish 'poly-noweb+r-mode))

Navigate through chunks: ~C-PageUp~ / ~C-PageDown~ go to previous/next
chunk; ~C-S-PageUp~ / ~C-S-PageDown~ go to previous/next chunk of the
same type:

#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'polymode
    (define-key polymode-mode-map [(C-prior)] #'polymode-previous-chunk)
    (define-key polymode-mode-map [(C-next)] #'polymode-next-chunk)
    (define-key polymode-mode-map [(C-S-prior)] #'polymode-previous-chunk-same-type)
    (define-key polymode-mode-map [(C-S-next)] #'polymode-next-chunk-same-type))
#+END_SRC

# (setq 
# 	pm-weaver "knitR-ESS"		; Default weaver
# 	pm-exporter "pandoc")		; Default exporter
# (bind-keys :map polymode-mode-map
# 		  ([(f8)] . polymode-weave)       ; F7 to weave
# 		  ([(C-f8)] . polymode-export)))) ; C-F7 to export


* Postface

Of course, the very last part of this =init.org= file is the very
function that enables Emacs to regenerate both =init.el= and
=init.elc= files every time the =init.org= file is saved:

#+BEGIN_SRC emacs-lisp
  (defun tangle-init ()
    "If the current buffer is 'init.org' the code-blocks are
  tangled, and the tangled file is compiled."
    (when (equal (buffer-file-name)
                 (expand-file-name (concat user-emacs-directory "init.org")))
      ;; Avoid running hooks when tangling.
      (let ((prog-mode-hook nil))
        (org-babel-tangle)
        (byte-compile-file (concat user-emacs-directory "init.el")))))
  
  (add-hook 'after-save-hook 'tangle-init)
#+END_SRC
